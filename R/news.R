#' @include estimation.R
DFMNEWS<-'JD3_DfmNews'

.jd2r_dfmNews <- function(jnews, series_names, transformed = TRUE, target_factor_type = "M"){

  suffix<-ifelse(transformed, "_T", "")

  fcst_periods<-rjd3toolkit::result(jnews,"forecasts_periods")

  base<-data.frame(series=series_names[rjd3toolkit::result(jnews,"series_index")+1],
                   period=rjd3toolkit::result(jnews,"series_period"),
                   expected_value=rjd3toolkit::result(jnews,paste0("series_expected_value", suffix)),
                   observed_value=rjd3toolkit::result(jnews,paste0("series_observed_value", suffix)),
                   news=rjd3toolkit::result(jnews,paste0("series_news", suffix)))
  w<-rjd3toolkit::result(jnews,paste0("series_weights", suffix))
  i<-rjd3toolkit::result(jnews,paste0("series_impacts", suffix))
  colnames(w)<-paste0("weights(", fcst_periods, ")")
  colnames(i)<-paste0("impacts(", fcst_periods, ")")
  weights<-cbind(base, w)
  impacts<-rbind(cbind(base, i), c("TOTAL", rep(NA,4), apply(i, 2, sum)))
  fcsts<-rbind(rjd3toolkit::result(jnews,paste0("old_forecasts", suffix)),
               rjd3toolkit::result(jnews,paste0("revised_forecasts", suffix)),
               rjd3toolkit::result(jnews,paste0("new_forecasts", suffix)))
  colnames(fcsts)<-fcst_periods
  rownames(fcsts)<-c("old_forecasts", "revised_forecasts", "new_forecasts")

  if (target_factor_type == "Q"){
    nc<-ncol(fcsts)
    for(j in nc:1){
      nkj<-nchar(fcst_periods[j])
      mth<-as.numeric(substr(fcst_periods[j],1,nkj-5))
      if (mth%%3 == 0){
        yr_str<-substr(fcst_periods[j],nkj-4,nkj)
        colnames(weights)[j+5]<-paste0("weights(Q", mth/3, yr_str,")")
        colnames(impacts)[j+5]<-paste0("Impacts(Q", mth/3, yr_str,")")
        colnames(fcsts)[j]<-paste0("Q", mth/3, yr_str)
      } else {
        weights<-weights[,-(j+5)]
        impacts<-impacts[,-(j+5)]
        fcsts<-fcsts[,-j,drop=FALSE]
      }
    }
  }

  return(list(weights=weights, impacts=impacts, fcsts=fcsts))
}

#' DFM News analysis
#'
#' @param dfm_estimates an object of class 'JD3_DfmEstimates'. Typically
#'   generated by the functions estimate_pca(), estimate_em() or estimate_ml().
#' @param new_data an mts object containing the updated dataset.
#' @param target_series the name of the series of interest. By default, the
#'   first series is considered.
#' @param n_fcst the number of forecasting periods to consider. Default is 3.
#' @return An object of class 'JD3_DfmNews'
#' @export
#'
#' @examples
#' set.seed(100)
#' data_t1<-ts(matrix(rnorm(500), 100, 5), frequency = 12, start = c(2010,1))
#' data_t1[100,1]<-data_t1[99:100,2]<-data_t1[(1:100)[-seq(3,100,3)],5]<-NA
#' data_t2<-ts(rbind(data_t1, rep(NA,5)), frequency = 12, start = c(2010,1))
#' data_t2[100,1]<-data_t2[99,2]<-data_t2[101,3]<-data_t2[101,4]<-1
#'
#' dfm_model <- create_model(nfactors=2,
#'                           nlags=2,
#'                           factors_type = c("M", "M", "YoY", "M", "Q"),
#'                           factors_loading = matrix(TRUE, 5, 2),
#'                           var_init = "Unconditional")
#'
#' est_em<-estimate_em(dfm_model, data_t1)
#' # or to use any previous frozen model:
#' # est_em_frozen<-estimate_em(dfm_model, data_t1, re_estimate = FALSE)
#'
#' news<-get_news(est_em, data_t2, target_series = "Series 2", n_fcst = 2)
#'
#' @references Banbura and Modugno (2010) - Maximum likelihood estimation of factor models on data sets with arbitrary pattern of missing data
#'
get_news<-function(dfm_estimates, new_data, target_series = NULL, n_fcst = 3){

  old_data<-dfm_estimates$data
  series_names<-colnames(old_data)

  if (!is.null(target_series)){
    target_series_index<-which(colnames(old_data) == target_series) - 1

    if (length(target_series_index) == 0){
      target_series_index<-0
      warning("Target series not found. The first series was considered by default instead.")
    }
  } else {
    target_series<-series_names[1]
    target_series_index<-0
  }

  if (n_fcst < 1){
    n_fcst<-3
  }
  target_factor_type<-dfm_estimates$dfm$factors_type[target_series_index + 1]
  if (target_factor_type == "Q"){
    n_fcst <- n_fcst*3
  }

  jdfm<-.r2jd_dfm(dfm_estimates$dfm)
  jold_data<-rjd3toolkit::.r2jd_matrix(old_data)
  jnew_data<-rjd3toolkit::.r2jd_matrix(new_data)
  freq<-stats::frequency(old_data)
  start<-start(old_data)
  jnews<-rjd3toolkit::.jd3_object(
    .jcall("jdplus/dfm/base/r/DynamicFactorModels",
           "Ljdplus/dfm/base/core/DfmResultsNews;",
           "computeNews",
           as.integer(target_series_index),
           jdfm$internal,
           jold_data,
           jnew_data,
           as.integer(freq),
           .jarray(as.integer(start)),
           dfm_estimates$is_standardized,
           as.integer(n_fcst)), result = TRUE)

  rnews_T<-.jd2r_dfmNews(jnews, series_names, transformed = TRUE, target_factor_type)
  rnews<-.jd2r_dfmNews(jnews, series_names, transformed = FALSE, target_factor_type)

  return(structure(list(
    target_series=target_series,
    weights_T=rnews_T$weights,
    impacts_T=rnews_T$impacts,
    forecasts_T=rnews_T$fcsts,
    weights=rnews$weights,
    impacts=rnews$impacts,
    forecasts=rnews$fcsts),
    class = DFMNEWS))
}

#' Plot function for objects of class 'JD3_DfmNews'
#'
#' @param x an object of class 'JD3_DfmNews'
#' @param \dots further arguments passed to barplot().
#' @exportS3Method plot JD3_DfmNews
#' @export
#'
plot.JD3_DfmNews <- function(x, ...){

  start_i<-6
  x_impacts<-x$impacts
  x_fcsts<-x$forecasts

  nr<-nrow(x_impacts)
  nc_fcst<-ncol(x_fcsts)
  impacts<-as.matrix(sapply(x_impacts[-nr,start_i:(start_i+nc_fcst-1)], as.numeric))
  impacts_tot<-as.numeric(x_impacts[nr,start_i:(start_i+nc_fcst-1)])
  colnames(impacts)<-colnames(x_fcsts)
  rownames(impacts)<-x_impacts[-nr,1]
  if (nr <= 10){
    plot_colors<-grDevices::palette.colors(nr-1)
  } else {
    plot_colors<-grDevices::colorRampPalette(grDevices::palette.colors(8))(nr-1)
  }
  legend_txt<-paste0(x_impacts[-nr,1], " (", x_impacts[-nr,2], ")")
  legend_txt<-c(legend_txt, "Total impact")

  graphics::par(mar=c(5.1, 4.1, 4.1, 16.1), xpd=TRUE)

  # workaround to handle barplots with negative values
  impacts_neg<-impacts_pos<-impacts
  impacts_neg[impacts_neg<0]<-0
  impacts_pos[impacts_pos>0]<-0
  impacts_range<-c(min(colSums(impacts_pos)),max(colSums(impacts_neg)))
  bp_intervals<-graphics::barplot(impacts_neg, ylim = impacts_range,
                                  main = paste0("Impacts of news on forecasts (", x$target_series, ")"), col = plot_colors,
                                  las = 1, ...)
  graphics::barplot(impacts_pos, add = TRUE, ylim = rev(impacts_range),
                    col =  plot_colors, las = 1, ...)
  graphics::points(x=bp_intervals, y=impacts_tot, cex = 1, pch = 3, col ="red")
  graphics::lines(x=bp_intervals, y=impacts_tot, col ="red")
  graphics::legend("bottomright", legend = legend_txt, inset = c(-0.6, 0),
                   col=c(plot_colors, "red"), pch = c(rep(15,nr-1),3))
}

#' Summary function for objects of class 'JD3_DfmNews'
#'
#' @param object an object of class 'JD3_DfmNews'
#' @param \dots further arguments passed to the print() function.
#' @exportS3Method summary JD3_DfmNews
#' @export
#'
summary.JD3_DfmNews <- function(object, ...){

  x <- object

  nf<-ncol(x$forecasts)

  base<-cbind(x$impacts[,1:2], sapply(x$impacts[,3:5], function(a) round(as.numeric(a),3)))

  weights<- rbind(sapply(x$weights[,6:ncol(x$weights),drop=FALSE], as.numeric),
                  apply(x$weights[,6:ncol(x$weights)],drop=FALSE, 2, sum))
  impacts<-sapply(x$impacts[,6:ncol(x$impacts)], as.numeric)
  tmp<-matrix(NA, nrow=nrow(weights), ncol=ncol(weights)*2)
  cnames_tmp<-character(ncol(weights)*2)

  for(j in 1:nf){
    tmp[,(2*j)-1]<-round(weights[,j],3)
    tmp[,(2*j)]<-round(impacts[,j],3)
    cnames_tmp[(2*j)-1]<-colnames(x$weights)[j+5]
    cnames_tmp[(2*j)]<-colnames(x$impacts)[j+5]
  }
  colnames(tmp)<-cnames_tmp

  summary_news<-cbind(base, tmp)

  print(list(target_series = x$target_series,
             summary_news = summary_news, ...), row.names = FALSE)
}

#' Print function for objects of class 'JD3_DfmNews'
#'
#' @param x an object of class 'JD3_DfmNews'
#' @param \dots further arguments passed to the print() function.
#' @exportS3Method print JD3_DfmNews
#' @export
#'
print.JD3_DfmNews <- function(x, ...){

  summary(x)
  print(list(forecasts = round(x$forecasts,3), ...))
}
